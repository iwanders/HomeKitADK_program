

#include <map>
#include <unistd.h>
#include <vector>
#include <string>
#include <memory>
#include <thread>
#include <sstream>
#include <fstream>
#include <iostream>
#include <iomanip>
#include <deque>
#include <filesystem>

#include "HAPLog.h"
#include "HAPPlatformBLEPeripheralManager+Init.h"
#include "HAPPlatformBLEPeripheralManager.h"
#include "HAPAssert.h"

struct GDBusConnection;
struct GMainLoop;

#include "HAPPlatformLinuxShared.h"

using Bytes = std::vector<std::uint8_t>;

static const HAPLogObject logObject = { .subsystem = kHAPPlatform_LogSubsystem, .category = "BLEPeripheralManager" };

static OurBLEContainer* our_container = nullptr;

Bytes on_local_char_read(const OurBLEContainer* c, const char *service_uuid, const char *char_uuid);
bool on_local_char_write(const OurBLEContainer* c, const char *service_uuid, const char *char_uuid, Bytes byteArray);

// Random bytes is consumed from the left side, we can append to it.
static std::deque<std::uint8_t> random_bytes;

void writeStateMarker();
void writeLongtermSecretKey(const Bytes& key);
void writeSaltAndVerifier(const Bytes& salt, const Bytes& verifier);
void writeDeviceId(const Bytes& data);
void writePairFourLetter(const Bytes& data);
void appendRandomBytes(const Bytes& data);
std::string hexdump(const Bytes& bytes)
{
  const auto b = bytes.data();
  const auto length = bytes.size();
  const uint8_t* d = reinterpret_cast<const uint8_t*>(b);
  std::stringstream ss;
  for (std::size_t i = 0; i < length; i++)
  {
    ss << "0x" << std::setfill('0') << std::setw(2) << std::hex << int{ d[i] } << ", ";
  }
  const auto z = ss.str();
  HAPLogInfo(&logObjectBleLinuxShared, "hdump %s", z.c_str());
  return z;
}

void test_message_exchange(OurBLEContainer* c);

void  run_main_loop(void* _Nullable context, size_t contextSize) {
  // THis is a pointer to a pointer.
  OurBLEContainer* c = *reinterpret_cast<OurBLEContainer**>(context);
  std::cout << "Doing c->delegate.handleConnectedCentral " << c->delegate.handleConnectedCentral << std::endl;
  std::cout << "Doing c->manager " << c->manager << std::endl;

  if (c->delegate.handleConnectedCentral && c->manager) {
    std::cout << "cc things" << std::endl;

    c->connection_handle++;
    (*(c->delegate.handleConnectedCentral))(c->manager, c->connection_handle, c->delegate.context);
    test_message_exchange(c); // never returns.
  }
  usleep(100);

  int r = HAPPlatformRunLoopScheduleCallback(run_main_loop, &c,sizeof(void*));
  HAPAssert(r == kHAPError_None);
}

void test_message_setup(){
  writeStateMarker();
  writeLongtermSecretKey({
    0x15, 0xf5, 0xa7, 0xdb, 0xa0, 0x11, 0x21, 0xea, 0x23, 0xea, 0x88, 0x7f, 0x0a, 0x14, 0xb0,
    0x27, 0xb6, 0xe6, 0xd4, 0x2d, 0xd1, 0x5b, 0xc9, 0x59, 0x19, 0x94, 0xbc, 0x22, 0xee, 0x52,
    0xfa, 0xa9,});
  writeDeviceId({0x57, 0x3b, 0x20, 0xA7, 0xE7, 0xC4});
  writePairFourLetter({0x44, 0x55, 0x48, 0x5a, 0x00  });
  writeSaltAndVerifier({0x3d, 0xc2, 0x81, 0xab, 0x08, 0xed, 0x4d, 0x8c, 0x52, 0x0c, 0xb2, 0x5f, 0xc2, 0x51, 0x9c,
  0x1f},{0xe3, 0x7e, 0xa0, 0xd4, 0x45, 0xab, 0x91, 0xcc, 0xee, 0x92, 0x33, 0x20, 0x9e, 0xb3, 0x8f,
  0xfc, 0xd7, 0x04, 0x20, 0xd1, 0x95, 0x34, 0x73, 0x5a, 0x17, 0x2e, 0xca, 0xef, 0xe3, 0x8d,
  0x1a, 0x21, 0xfb, 0x5e, 0x2d, 0x18, 0x1b, 0xb0, 0x80, 0x77, 0x12, 0xf7, 0x2d, 0x2e, 0x64,
  0x67, 0xc7, 0xa8, 0xb5, 0xc0, 0xe3, 0xab, 0xe4, 0x60, 0x58, 0x9f, 0xde, 0x39, 0x62, 0xdc,
  0x70, 0x01, 0x42, 0x1a, 0x07, 0x47, 0x16, 0x63, 0xf7, 0xd7, 0xee, 0x9b, 0xf9, 0x7b, 0x35,
  0xc4, 0x3b, 0x5d, 0x0a, 0xd6, 0x07, 0xdb, 0x47, 0x84, 0x05, 0x22, 0x9b, 0xc8, 0x0f, 0xb3,
  0xb4, 0x39, 0xc7, 0x18, 0xc9, 0xb0, 0x85, 0x8d, 0x19, 0xf5, 0x56, 0xc6, 0xee, 0x9b, 0xd8,
  0x87, 0x8a, 0x39, 0xf9, 0x21, 0x35, 0xaa, 0x42, 0x50, 0x6d, 0xa3, 0x5a, 0x3f, 0x67, 0x55,
  0x6a, 0x5c, 0x6c, 0x92, 0x07, 0x44, 0xd3, 0xd6, 0x97, 0x6b, 0x5a, 0x5c, 0xcf, 0x6b, 0xdf,
  0xf5, 0x1d, 0x4c, 0xde, 0x3f, 0x2d, 0xf7, 0x95, 0x3c, 0x70, 0xde, 0x65, 0xcf, 0x22, 0x96,
  0xe8, 0x12, 0x8f, 0xa7, 0x9a, 0xa7, 0x68, 0xfe, 0x00, 0x18, 0x7f, 0x6d, 0xed, 0x98, 0xc9,
  0x6b, 0xfc, 0xd2, 0x9b, 0xa9, 0x08, 0x93, 0x3e, 0x3e, 0x7f, 0x7c, 0x63, 0x03, 0x49, 0xdf,
  0x52, 0x18, 0xcf, 0x9f, 0xf3, 0xbb, 0x11, 0xb5, 0xa3, 0x05, 0x03, 0x6b, 0xba, 0xf8, 0x91,
  0x60, 0xc2, 0xf1, 0x1e, 0x5f, 0x0c, 0x81, 0x08, 0x25, 0xda, 0xed, 0xef, 0xa0, 0xfe, 0x73,
  0xbf, 0xd8, 0xe3, 0xdb, 0xdc, 0xf6, 0x54, 0x42, 0x9a, 0xea, 0xf2, 0x69, 0x46, 0x14, 0x0c,
  0x86, 0x97, 0x56, 0x95, 0x8b, 0x5b, 0x1f, 0x87, 0x99, 0x5c, 0xaf, 0x6a, 0xf4, 0xe5, 0x66,
  0xe9, 0xf9, 0x7b, 0xa5, 0x1f, 0xf8, 0x8e, 0xa7, 0x81, 0xcc, 0x4e, 0xdd, 0x20, 0x94, 0x2d,
  0x31, 0x78, 0xb6, 0x26, 0xf6, 0x41, 0x07, 0xa7, 0xad, 0x97, 0x18, 0xff, 0x7a, 0x0f, 0x3c,
  0x55, 0x4b, 0xc3, 0x4d, 0x58, 0xc9, 0x56, 0xed, 0x6b, 0x69, 0xc4, 0x56, 0xf4, 0xf0, 0x5f,
  0x58, 0x7f, 0x98, 0xfa, 0x4a, 0xf7, 0x8e, 0xda, 0x49, 0xc8, 0x69, 0x88, 0xae, 0x9c, 0x39,
  0x1f, 0xa2, 0xc4, 0x58, 0x78, 0x35, 0xba, 0x73, 0x01, 0xae, 0xa2, 0xa9, 0x4d, 0x90, 0xf3,
  0x98, 0x14, 0xb9, 0x6f, 0x4f, 0x21, 0x01, 0xdd, 0xad, 0x1a, 0x52, 0x45, 0x13, 0xe9, 0x08,
  0xb0, 0x89, 0x54, 0xee, 0xe3, 0x44, 0x08, 0xd4, 0x77, 0x4b, 0xab, 0x65, 0x6e, 0xba, 0xec,
  0xf9, 0xce, 0x9d, 0x5f, 0xd5, 0x4a, 0xde, 0xdf, 0x8f, 0x67, 0x47, 0x65, 0xe2, 0x2f, 0x8f,
  0x9f, 0x53, 0xab, 0x56, 0xb1, 0x22, 0x6c, 0xe3, 0x5c, 0x8e, 0x97, 0x2f, 0x9f, 0x82, 0xf1,
  0xd2, 0x11, 0x2f, 0x1a, 0xc3, 0x2a, 0x60, 0x28, 0x83});
}

// Do a global initialisation trick to get an execution in before any of the other HAP code gets cycles.
// This allows us to switch to a temporary directory for a fresh run. Where we can make a nice mess out of the
// kv store =)
struct TestMessageExchangeConstructorTrick{
  TestMessageExchangeConstructorTrick() {
    std::cout << " I run early " << std::endl;

    auto now = std::chrono::system_clock::now();
    std::time_t now_c = std::chrono::system_clock::to_time_t(now);
    std::tm now_tm = *std::localtime(&now_c);
    std::stringstream ss;
    ss << std::put_time(&now_tm, "%Y-%m-%d_%H-%M-%S");
    std::string directory_name = ss.str();

    std::filesystem::path base_dir_path = "/tmp/hap_test/";
    std::filesystem::create_directory(base_dir_path);
    std::filesystem::path dir_path =base_dir_path / ("test_" + directory_name );

    std::filesystem::create_directory(dir_path);

    // Change the directory to that new directory.
    std::filesystem::current_path(dir_path);

    // And then symlink that .HomeKitStore dir that the it wants into the directory
    // such that we can look at the files easily and write them without subpaths.
    std::filesystem::path store_path = dir_path / ".HomeKitStore";
    std::filesystem::create_symlink(dir_path, store_path);
    test_message_setup();
  }
};
static TestMessageExchangeConstructorTrick z;


static std::size_t exchange_counter = 0;
void test_exchange(OurBLEContainer* c, const CharacteristicId& char_id, const Bytes& write, const Bytes& read_check){
  const auto srv_uuid_str = std::string(char_id.service);
  const auto srv_uuid  = srv_uuid_str.c_str();
  const auto chr_uuid_str = std::string(char_id.characteristic);
  const auto chr_uuid  = chr_uuid_str.c_str();

  if (!on_local_char_write(c , srv_uuid, chr_uuid, write))
  {
    throw std::runtime_error(std::string("Write failed to srv: ") + srv_uuid + " and char: " + chr_uuid);
  }
  const auto res = on_local_char_read(c, srv_uuid, chr_uuid);
  // Verify they are identical.
  if (res != read_check){
    std::cerr << "Expected bytes: " << hexdump(read_check) << std::endl;
    std::cerr << "Got bytes: " << hexdump(res) << std::endl;
    throw std::runtime_error(std::string("Read failed to srv: ") + srv_uuid + " and char: " + chr_uuid);
  } else {
    std::cout << "Exchange " << exchange_counter << "  to " << srv_uuid << " : " << chr_uuid << " with " << write.size() << " and " << read_check.size() << " Succesful" << std::endl;
  }
  exchange_counter++;
}

void test_message_exchange(OurBLEContainer* c){
    const auto proto_srv = "000000a2-0000-1000-8000-0026bb765291";
    const auto proto_service_sig_chr = "000000a5-0000-1000-8000-0026bb765291";
    const auto pairing_srv = "00000055-0000-1000-8000-0026bb765291";
    const auto pairing_srv_pair_setup_chr = "0000004c-0000-1000-8000-0026bb765291";
    const auto pairing_srv_pair_verify_chr = "0000004e-0000-1000-8000-0026bb765291";
    const auto bulb_srv = "00000043-0000-1000-8000-0026bb765291";
    const auto bulb_srv_on_chr = "00000025-0000-1000-8000-0026bb765291";



    const auto accessory_srv = "0000003e-0000-1000-8000-0026bb765291";
    const auto accessory_srv_hardware_rev_chr = "00000053-0000-1000-8000-0026bb765291";
    const auto accessory_srv_firmware_rev_chr = "00000052-0000-1000-8000-0026bb765291";
    const auto accessory_srv_model_chr = "00000021-0000-1000-8000-0026bb765291";
    const auto accessory_srv_identify_chr = "00000014-0000-1000-8000-0026bb765291";
    const auto accessory_srv_manufacturer_chr = "00000020-0000-1000-8000-0026bb765291";
    const auto accessory_srv_serial_number_chr = "00000030-0000-1000-8000-0026bb765291";
    const auto name_chr = "00000023-0000-1000-8000-0026bb765291";

    const auto protocol_information_srv = "000000a2-0000-1000-8000-0026bb765291";
    const auto service_signature_chr = "000000a5-0000-1000-8000-0026bb765291";
    const auto version_chr = "00000037-0000-1000-8000-0026bb765291";

     const auto handle_hardware_revision = CharacteristicId::service_characteristic(accessory_srv, accessory_srv_hardware_rev_chr);
     const auto handle_model_number = CharacteristicId::service_characteristic(accessory_srv, accessory_srv_model_chr);
     const auto handle_firmware_version = CharacteristicId::service_characteristic(accessory_srv, accessory_srv_firmware_rev_chr);
     const auto handle_identify = CharacteristicId::service_characteristic(accessory_srv, accessory_srv_identify_chr);

     const auto handle_manufacturer = CharacteristicId::service_characteristic(accessory_srv, accessory_srv_manufacturer_chr);
     const auto handle_name = CharacteristicId::service_characteristic(accessory_srv, name_chr);
     const auto handle_serial_number = CharacteristicId::service_characteristic(accessory_srv, accessory_srv_serial_number_chr);


     const std::uint8_t adk_bytes[16] = {0x3b, 0x94, 0xf9, 0x85, 0x6a, 0xfd, 0xc3, 0xba, 0x40, 0x43, 0x7f, 0xac, 0x11, 0x88, 0xab, 0x34};
     RawUUID adk_uuid = RawUUID::fromBytes(adk_bytes);
     const auto handle_adk_version = CharacteristicId::service_characteristic(accessory_srv, std::string(adk_uuid).c_str());


     const auto handle_protocol_service_signature = CharacteristicId::service_characteristic(protocol_information_srv, service_signature_chr);

     const auto handle_protocol_version = CharacteristicId::service_characteristic(protocol_information_srv, version_chr);

     const auto pairing_pairings_chr = "00000050-0000-1000-8000-0026bb765291";
     const auto handle_pairing_pairings = CharacteristicId::service_characteristic(pairing_srv, pairing_pairings_chr);
    const auto pairing_pair_setup = CharacteristicId::service_characteristic(pairing_srv, pairing_srv_pair_setup_chr);
    const auto pairing_pair_verify = CharacteristicId::service_characteristic(pairing_srv, pairing_srv_pair_verify_chr);


    const auto lightbulb_srv = "00000043-0000-1000-8000-0026bb765291";
    const auto on_chr = "00000025-0000-1000-8000-0026bb765291";
    const auto handle_lightbulb_on = CharacteristicId::service_characteristic(lightbulb_srv, on_chr);
    const auto handle_lightbulb_service_signature = CharacteristicId::service_characteristic(lightbulb_srv, service_signature_chr);
    const auto handle_lightbulb_name = CharacteristicId::service_characteristic(lightbulb_srv, name_chr);

    appendRandomBytes({0x75, 0x35, 0xcb, 0x53, 0x6e, 0xbb, 0x8c, 0x63, 0x94, 0xf5, 0x85, 0xe6, 0x7d, 0xc5, 0x65,
    0x2d, 0x83, 0xe4, 0xea, 0x76, 0x4c, 0xa3, 0x61, 0xe3, 0x85, 0xca, 0x07, 0x57, 0x29, 0x47,
    0x2d, 0x55,});

    // M1 & M2
    test_exchange(c, pairing_pair_setup,
      {
        0x00, 0x02, 0xf3, 0x22, 0x00, 0x0b, 0x00, 0x01, 0x06, 0x00, 0x01, 0x00, 0x06, 0x01,
        0x01, 0x09, 0x01, 0x01
      },
      {
        0x02, 0xf3, 0x00, 0x9d, 0x01, 0x01, 0xff, 0x06, 0x01, 0x02, 0x03, 0xff, 0x64, 0x43,
      0x37, 0x03, 0x65, 0x86, 0x5d, 0x21, 0x46, 0xa6, 0x85, 0x54, 0x0d, 0x38, 0x8a, 0x51,
      0x84, 0xb8, 0x35, 0x51, 0x90, 0x69, 0x57, 0xd2, 0x38, 0x5b, 0xab, 0xdc, 0x5a, 0xf3,
      0x97, 0xbc, 0xdc, 0x35, 0x24, 0x31, 0x99, 0x17, 0xcc, 0xf2, 0x5c, 0xbb, 0x6e, 0x3c,
      0x4a, 0x5b, 0x35, 0x83, 0x7c, 0x20, 0x60, 0x0f, 0x45, 0x79, 0x39, 0x3e, 0xfa, 0x90,
      0xfc, 0xa0, 0x5c, 0x71, 0xe5, 0x1b, 0x39, 0xf8, 0x8c, 0x4e, 0xd8, 0xe6, 0xcf, 0xb9,
      0xdc, 0x05, 0xb6, 0x18, 0x75, 0x2b, 0xa4, 0xc8, 0x90, 0x06, 0x66, 0x80, 0x85, 0x92,
      0x7a, 0x80, 0xd4, 0x08, 0x3a, 0xfc, 0x36, 0x40, 0xad, 0xa3, 0x7b, 0xdc, 0xa2, 0x6b,
      0x49, 0x71, 0x0a, 0x25, 0xc1, 0x97, 0x27, 0x7f, 0x8f, 0x8e, 0x28, 0xa1, 0xf9, 0xff,
      0x6a, 0x87, 0x32, 0x29, 0x72, 0x24, 0x59, 0x4a, 0xf3, 0xfa, 0xcd, 0xe5, 0xae, 0xe7,
      0x3e, 0x90, 0xa5, 0xb0, 0xfa, 0x9e, 0x80, 0x2b, 0xe0, 0x53, 0x33, 0xf2, 0xe7, 0x4b,
      0x6b, 0xdd, 0x56, 0x69, 0x9b, 0x40, 0xed, 0x24, 0xbd, 0x98, 0x23, 0xc2, 0x7b, 0x68,
      0xb7, 0xd9, 0x8f, 0xd6, 0xb4, 0x52, 0x90, 0x42, 0x07, 0xd5, 0x48, 0x63, 0xe0, 0xc6,
      0xd7, 0x18, 0x95, 0xc6, 0xc0, 0x8f, 0x80, 0xe7, 0xc6, 0x02, 0x7c, 0x06, 0x19, 0x8f,
      0x9f, 0xcc, 0xa7, 0x80, 0x67, 0x85, 0x2b, 0xa8, 0x8d, 0x11, 0xcd, 0xdd, 0xa9, 0x98,
      0xa4, 0x75, 0xe8, 0xde, 0xec, 0xfc, 0xf4, 0x92, 0x0d, 0x26, 0xb4, 0x10, 0xbc, 0xc4,
      0x48, 0x98, 0x07, 0x5b, 0x5e, 0x0f, 0x63, 0x47, 0x33, 0xe0, 0x50, 0xc0, 0xbe, 0x8a,
      0x9d, 0x31, 0xe0, 0x44, 0x7d, 0x26, 0x62, 0xf1, 0xc4, 0x98, 0x2b, 0x6d, 0x08, 0x5b,
      0xde, 0xac, 0xea, 0x83, 0xf7, 0x8a, 0x6f, 0xa6, 0x2d, 0x6d, 0x01, 0x9a, 0x54, 0x8a,
      0xc5, 0xf9, 0x7d, 0x03, 0x81, 0xc7, 0x65, 0x77, 0xe1, 0x64, 0x9c, 0xad, 0x5f, 0x28,
      0x78, 0xc8, 0x25, 0x57, 0x89, 0x00, 0xff, 0x7e, 0xc9, 0x9f, 0x4e, 0x87, 0x43, 0xe9,
      0x1a, 0x05, 0x6d, 0xcd, 0x50, 0x2c, 0xa2, 0x85, 0x52, 0xef, 0x7a, 0x8a, 0xf1, 0xe0,
      0x3a, 0x38, 0x2a, 0x76, 0x1c, 0x61, 0xaf, 0x06, 0xb3, 0xf9, 0x3d, 0x8b, 0xb6, 0x1b,
      0xab, 0x6c, 0x14, 0xa3, 0x7b, 0xe0, 0x4c, 0x45, 0x3c, 0xb5, 0x95, 0x2e, 0x96, 0xc5,
      0xb5, 0x23, 0xc7, 0x9e, 0xf6, 0xdd, 0xa3, 0xa2, 0x67, 0x6d, 0x7d, 0x54, 0x44, 0xe1,
      0x3b, 0x4c, 0xaa, 0xf3, 0x99, 0x89, 0xc9, 0xa0, 0x23, 0x6f, 0xf2, 0x94, 0x60, 0x7b,
      0x64, 0x1f, 0x1f, 0xea, 0xa2, 0x11, 0x63, 0x42, 0x10, 0xfb, 0x3c, 0xeb, 0x97, 0x9f,
      0x07, 0xc5, 0x9e, 0x7c, 0x54, 0x2b, 0xd6, 0x6d, 0x21, 0x5d, 0x3e, 0x26, 0x50, 0x80,
      0x0b, 0xa1, 0xce, 0xdb, 0xc0, 0x99, 0x3c, 0x16, 0x02, 0x10, 0x3d, 0xc2, 0x81, 0xab,
      0x08, 0xed, 0x4d, 0x8c, 0x52, 0x0c, 0xb2, 0x5f, 0xc2, 0x51, 0x9c, 0x1f,}
    );

    // M3 & M4

    test_exchange(c, pairing_pair_setup,
      {
            0x00, 0x02, 0x5d, 0x22, 0x00, 0xd0, 0x01, 0x01, 0xff, 0x06, 0x01, 0x03, 0x03, 0xff,
            0xc9, 0x50, 0x62, 0x39, 0x72, 0xb4, 0x32, 0x9a, 0x6c, 0xbd, 0x1d, 0xc6, 0x52, 0x46,
            0xea, 0xdc, 0x2d, 0xe6, 0xd1, 0xd1, 0xa2, 0x16, 0x3f, 0x24, 0x21, 0xb1, 0x04, 0x40,
            0x08, 0xc2, 0xd7, 0xbf, 0xb2, 0xeb, 0x3e, 0x70, 0x7d, 0x8d, 0x1d, 0xca, 0x28, 0xed,
            0x48, 0xff, 0x79, 0x95, 0xea, 0x3b, 0x7f, 0xc1, 0x31, 0x5f, 0x8b, 0x72, 0xb3, 0xb6,
            0x33, 0xf3, 0x98, 0x80, 0x7f, 0x5c, 0x2c, 0xd6, 0x11, 0x5a, 0xa8, 0xf6, 0x35, 0x10,
            0xf5, 0xd0, 0x2a, 0x21, 0x75, 0xdc, 0x03, 0xd7, 0x5e, 0x9e, 0xbb, 0x82, 0x4e, 0x20,
            0xef, 0x66, 0xed, 0x63, 0x95, 0xe5, 0x49, 0x3e, 0x13, 0x13, 0x32, 0xa3, 0x9e, 0x55,
            0xaf, 0xea, 0xd0, 0xd4, 0x1a, 0x80, 0x18, 0xaa, 0x97, 0x4d, 0xf0, 0x1b, 0x25, 0xaf,
            0x96, 0x47, 0x34, 0x92, 0x9c, 0x5a, 0x42, 0xd4, 0xc7, 0xde, 0x42, 0xae, 0xc6, 0x8c,
            0xaa, 0x94, 0x88, 0xd0, 0xa2, 0x1f, 0xbc, 0xec, 0x90, 0xa5, 0x00, 0x00, 0xe4, 0xa1,
            0x74, 0x83, 0x0e, 0x69, 0x55, 0xf5, 0x3d, 0x2d, 0xc5, 0xf4, 0x11, 0x4e, 0xff, 0xae,
            0x7a, 0x85, 0xa3, 0x8c, 0x44, 0x0e, 0x12, 0x23, 0x87, 0x00, 0xa8, 0x19, 0x2a, 0x82,
            0xc7, 0xf2, 0x6d, 0x8d, 0xb9, 0x90, 0x04, 0xe7, 0xc5, 0xe8, 0x32, 0x4c, 0xcc, 0xad,
            0x7f, 0xbc, 0x5f, 0x9d, 0x96, 0xcd, 0xaa, 0xef, 0x03, 0x6a, 0xf9, 0xf2, 0xd6, 0x63,
            0x2c, 0xe9, 0xb0, 0xb3, 0x20, 0x18, 0xaf, 0x55, 0xd4, 0x50, 0x53, 0x47, 0xfe, 0xdc,
            0x60, 0x4f, 0xdd, 0xf9, 0xf2, 0x78, 0x24, 0xa6, 0xfc, 0x3a, 0x10, 0xcb, 0x97, 0x7c,
            0x5c, 0xbc, 0x4b, 0x9a, 0x83, 0xd2, 0x2b, 0x89, 0x6b, 0xc9, 0x36, 0x0b, 0xe1, 0x37,
            0x7e, 0x84, 0xfd, 0x3d, 0x25, 0x45, 0x45, 0x51, 0xf2, 0x4e, 0xba, 0x79, 0x01, 0xca,
            0xf9, 0x9c, 0x93, 0xa8, 0x69, 0x03, 0x81, 0x33, 0xd5, 0x56, 0x8d, 0xcf, 0x95, 0x10,
            0x7c, 0x20, 0xeb, 0x0c, 0xe8, 0x00, 0x1f, 0x1b, 0x9a, 0xdf, 0x0d, 0x01, 0xea, 0xa7,
            0x6f, 0xa4, 0xe1, 0xa7, 0x30, 0xe5, 0x62, 0x8a, 0x43, 0xe1, 0xa2, 0xf9, 0xb6, 0x13,
            0x3c, 0x69, 0x86, 0x3a, 0x97, 0x60, 0x98, 0xc5, 0xb4, 0x49, 0x56, 0xdc, 0x52, 0x69,
            0xe5, 0x8a, 0xda, 0xa3, 0x7f, 0x7b, 0xd4, 0xe5, 0x5d, 0xcb, 0xa0, 0xf6, 0x83, 0x4f,
            0x46, 0xa1, 0x74, 0xaa, 0xdf, 0xaf, 0xaa, 0x84, 0x39, 0xca, 0x01, 0xd7, 0xc9, 0xe0,
            0x6d, 0x36, 0x9b, 0x2c, 0x82, 0xe9, 0x85, 0x74, 0xef, 0x6c, 0x6c, 0xdf, 0xe7, 0xc4,
            0xcf, 0x71, 0x81, 0xf4, 0x07, 0x72, 0x59, 0x5b, 0xaa, 0xd5, 0x13, 0xeb, 0xda, 0x1c,
            0x33, 0xde, 0x43, 0xda, 0xac, 0xd2, 0xb4, 0x8e, 0x95, 0x79, 0xc6, 0x7f, 0x9e, 0x53,
            0xc9, 0x0c, 0xbe, 0x29, 0x2c, 0x5f, 0x7f, 0x35, 0x4e, 0x1a, 0x04, 0x40, 0x10, 0x6e,
            0x7f, 0x5d, 0x4b, 0xbd, 0x13, 0x0d, 0xf6, 0x52, 0x08, 0xdf, 0x83, 0x0c, 0xea, 0xf5,
            0x05, 0x47, 0x8b, 0x73, 0xc8, 0xdd, 0x04, 0x8f, 0xcf, 0xf7, 0xa3, 0x94, 0xed, 0x26,
            0x5c, 0x5e, 0x47, 0xb6, 0x18, 0xf6, 0xe0, 0xe2, 0x7f, 0xe1, 0xe1, 0x7b, 0xbc, 0x87,
            0x85, 0x81, 0x58, 0x64, 0x45, 0x94, 0x8f, 0xdc, 0xe8, 0x0a, 0xad, 0xeb, 0xa3, 0xf5,
            0x5b, 0x09, 0xf5, 0xbc, 0xb2, 0xa0, 0x09, 0x01, 0x01,
      },
      {
            0x02, 0x5d, 0x00, 0x47, 0x00, 0x01, 0x45, 0x06, 0x01, 0x04, 0x04, 0x40, 0xa0, 0xf2,
            0xc0, 0x55, 0x21, 0x57, 0xda, 0x19, 0x85, 0xcd, 0x0c, 0x0f, 0xcb, 0x76, 0x80, 0xa7,
            0xc3, 0x11, 0xf3, 0x2d, 0xe7, 0xb1, 0xed, 0x3b, 0xb9, 0xc8, 0xae, 0xab, 0xee, 0x07,
            0x1a, 0xbc, 0x0c, 0xe5, 0xd8, 0xf2, 0x81, 0x8d, 0x6b, 0x92, 0xe8, 0x78, 0xcb, 0x5b,
            0xb6, 0xe4, 0xea, 0x0b, 0x31, 0xe2, 0xfd, 0xcd, 0x01, 0x2b, 0xaa, 0x73, 0x78, 0x7c,
            0x3f, 0xfe, 0x14, 0x3b, 0xdc, 0x19,
    }
    );

    // m5 & m6

    test_exchange(c, pairing_pair_setup,
      {
            0x00, 0x02, 0x06, 0x22, 0x00, 0xa4, 0x00, 0x01, 0x9f, 0x05, 0x9a, 0x46, 0xf1, 0xed,
            0x7b, 0x03, 0x13, 0x81, 0x27, 0xf4, 0x49, 0xf5, 0xd2, 0x58, 0x84, 0x3e, 0xab, 0x62,
            0x16, 0xcc, 0xb2, 0x81, 0x22, 0xcf, 0x0c, 0x24, 0x3e, 0xbb, 0x7c, 0xc1, 0xb0, 0x58,
            0x20, 0xb7, 0x49, 0x29, 0x86, 0xca, 0x7c, 0x5d, 0x22, 0x83, 0x4c, 0xdb, 0x3c, 0xeb,
            0x1f, 0x18, 0xb8, 0xc6, 0x5e, 0xdf, 0xed, 0x23, 0xcd, 0x15, 0xa7, 0x6b, 0x5f, 0xcd,
            0x3b, 0x50, 0xe2, 0x2d, 0x2f, 0x96, 0x34, 0x65, 0x35, 0x7d, 0xda, 0xdc, 0xbc, 0x18,
            0x5a, 0xe4, 0x27, 0x39, 0xfb, 0xe7, 0xf6, 0x41, 0xef, 0xe4, 0xb6, 0x51, 0x23, 0x68,
            0x55, 0x3b, 0xb2, 0x24, 0x3a, 0xed, 0xda, 0x1b, 0x5c, 0x6d, 0x9d, 0xf3, 0xe1, 0xfd,
            0x8b, 0xfd, 0x8a, 0xff, 0xf0, 0xb3, 0x09, 0xe0, 0x42, 0x8d, 0x8a, 0xe4, 0xea, 0x54,
            0xc1, 0x3e, 0xe1, 0x63, 0xec, 0xf8, 0x5a, 0x48, 0x03, 0x3f, 0xef, 0x17, 0xe0, 0x1f,
            0x18, 0x1c, 0x19, 0xb6, 0x0e, 0xad, 0x62, 0x1b, 0x90, 0x4f, 0xbe, 0x6a, 0x5f, 0x0a,
            0xdd, 0x6c, 0xb0, 0x42, 0x5a, 0xf0, 0xa3, 0xf9, 0xec, 0x62, 0xb0, 0x06, 0x01, 0x05,
            0x09, 0x01, 0x01,
      },
      {
            0x02, 0x06, 0x00, 0x8e, 0x00, 0x01, 0x8c, 0x06, 0x01, 0x06, 0x05, 0x87, 0xc0, 0x2d,
            0xab, 0x99, 0xf3, 0x9c, 0x2f, 0xeb, 0x40, 0xb4, 0x88, 0xe7, 0x8c, 0x9e, 0x0f, 0x7a,
            0x13, 0xe2, 0x4a, 0x5a, 0xd7, 0x66, 0xc9, 0x2b, 0x45, 0xd6, 0x72, 0x77, 0x81, 0x12,
            0xac, 0x57, 0x15, 0x8d, 0xb1, 0xae, 0x62, 0x7a, 0x69, 0x0c, 0xee, 0xf8, 0xeb, 0x31,
            0x3d, 0x39, 0xbf, 0x6b, 0x1f, 0xc8, 0x16, 0x57, 0x0b, 0x06, 0xf0, 0x56, 0x45, 0x87,
            0xfa, 0x33, 0x92, 0x9a, 0x69, 0x3c, 0xeb, 0x49, 0xc8, 0x9c, 0x06, 0xfb, 0xbe, 0xbf,
            0xec, 0xf7, 0x60, 0xba, 0x0b, 0xeb, 0x4d, 0x8a, 0xbe, 0x62, 0x9a, 0xe7, 0x16, 0xdc,
            0xa1, 0x61, 0x48, 0x3d, 0x2b, 0x78, 0x11, 0x75, 0xef, 0xe2, 0xb0, 0x63, 0xfe, 0x6c,
            0x3a, 0x86, 0x8c, 0x1c, 0x22, 0x9d, 0xcf, 0x3a, 0xb8, 0x61, 0x38, 0x18, 0x33, 0x09,
            0x54, 0xe8, 0xf1, 0xb9, 0x17, 0xa3, 0x81, 0xfe, 0x70, 0x50, 0x06, 0x7a, 0x9f, 0xd1,
            0x29, 0x85, 0x55, 0x77, 0x63, 0x9e, 0x04,
    }
    );

    // next pair verify.
    // and new random.
    //
    appendRandomBytes({0xe5, 0xb9, 0xee, 0xdd, 0x57, 0xd0, 0x40, 0x13, 0xf3, 0xaa, 0x88, 0xd9, 0x4b, 0x0d, 0x51,
    0xee, 0x92, 0x58, 0x9d, 0xfd, 0xa1, 0x5f, 0x96, 0x65, 0x2f, 0xee, 0x88, 0xd6, 0x3e, 0x0c,
    0x83, 0xc4});

    // Pair verify m1 & m2
    test_exchange(c, pairing_pair_verify,
      {
            0x00, 0x02, 0x34, 0x23, 0x00, 0x2a, 0x00, 0x01, 0x25, 0x06, 0x01, 0x01, 0x03, 0x20,
            0x1d, 0x74, 0xbd, 0x6a, 0x38, 0xdb, 0xea, 0x23, 0x6c, 0x1a, 0xcb, 0x88, 0x9a, 0xa7,
            0xb9, 0x6d, 0xde, 0x7f, 0x9c, 0xd5, 0x78, 0x34, 0x34, 0x12, 0xed, 0x1f, 0xf0, 0xac,
            0xf1, 0x02, 0x99, 0x01, 0x09, 0x01, 0x01,
      },
      {
            0x02, 0x34, 0x00, 0x8e, 0x00, 0x01, 0x8c, 0x06, 0x01, 0x02, 0x03, 0x20, 0x8f, 0x47,
            0x6d, 0xf6, 0x0c, 0xec, 0xdb, 0xe9, 0xc7, 0xf5, 0x4a, 0x6c, 0x2a, 0x6d, 0xbf, 0xd7,
            0x1e, 0xef, 0xd7, 0xf4, 0xf6, 0xf2, 0x73, 0xae, 0xf9, 0x5a, 0x41, 0xfc, 0x93, 0xec,
            0xa2, 0x0e, 0x05, 0x65, 0xbb, 0x5e, 0xc0, 0x3f, 0x8d, 0xb9, 0x8a, 0x1c, 0xd6, 0x47,
            0xc7, 0x83, 0x11, 0xe4, 0x26, 0xff, 0xd1, 0xbe, 0x30, 0xed, 0x7a, 0xef, 0xa0, 0x2c,
            0xed, 0x09, 0xe5, 0x17, 0xf0, 0x81, 0x0f, 0xaa, 0xc5, 0xd4, 0x93, 0x68, 0x5e, 0x32,
            0xc2, 0xf1, 0x48, 0xcb, 0xde, 0x0c, 0x03, 0x82, 0xd2, 0xbf, 0xa4, 0x9a, 0xb4, 0xe7,
            0x91, 0x77, 0x43, 0xa0, 0xd5, 0x72, 0x76, 0x08, 0xa1, 0x0f, 0x73, 0xa0, 0x84, 0x7b,
            0x42, 0xac, 0x79, 0x24, 0xaf, 0x0c, 0xf8, 0x22, 0x0e, 0x53, 0x25, 0x0d, 0xb2, 0xb1,
            0x98, 0xc0, 0x6b, 0xd2, 0xee, 0x1a, 0xaa, 0x9b, 0xb9, 0x7e, 0x6f, 0xab, 0x12, 0xa2,
            0xcf, 0x69, 0x7e, 0x04, 0xb0, 0x61, 0x0a,
    }
    );
        // Pair verify. m3 & m4
    test_exchange(c, pairing_pair_verify,
      {
            0x00, 0x02, 0xa9, 0x23, 0x00, 0x82, 0x00, 0x01, 0x7d, 0x05, 0x78, 0x74, 0xda, 0xba,
            0x6e, 0x05, 0x61, 0x68, 0xce, 0x07, 0x34, 0x28, 0xa6, 0xda, 0xb7, 0x4d, 0x78, 0x73,
            0x1a, 0x24, 0x42, 0x74, 0x20, 0x75, 0xdc, 0x90, 0x16, 0xea, 0xc2, 0x03, 0xd7, 0x06,
            0x6e, 0xf7, 0x30, 0x20, 0x21, 0xf6, 0xab, 0x7b, 0xa3, 0xe1, 0xa6, 0xb0, 0x16, 0x62,
            0x4f, 0xf0, 0x22, 0xf2, 0x03, 0xa3, 0x4a, 0x25, 0x1b, 0x78, 0xb0, 0x8b, 0x7c, 0x10,
            0xa8, 0x70, 0xb8, 0xe8, 0xa5, 0xba, 0x7e, 0xab, 0xcd, 0x38, 0x25, 0x78, 0x88, 0xb2,
            0xe3, 0x3e, 0xd4, 0x38, 0xde, 0x06, 0x1f, 0xce, 0x08, 0x5b, 0xb1, 0xf4, 0x0b, 0xef,
            0x8e, 0x00, 0x19, 0xc8, 0x47, 0xd3, 0x73, 0xef, 0xbb, 0xe1, 0x98, 0x34, 0x6e, 0x72,
            0xca, 0x24, 0x70, 0x30, 0xfb, 0x41, 0x59, 0xc0, 0x7a, 0x19, 0xa5, 0xba, 0xca, 0xe3,
            0x43, 0xa5, 0xb9, 0x3d, 0x93, 0x06, 0x01, 0x03, 0x09, 0x01, 0x01,
      },
      {
0x02, 0xa9, 0x00, 0x05, 0x00, 0x01, 0x03, 0x06, 0x01, 0x04
    }
    );


    // Secure session is now active!

    // Next request is on the hardware revision endpoint.
    test_exchange(c, handle_hardware_revision,
      {
            0xdf, 0x33, 0x41, 0x57, 0x50, 0x87, 0xeb, 0x71, 0x98, 0xb2, 0x88, 0x5a, 0xf4, 0xa1,
            0xe2, 0xbe, 0xf3, 0xe1, 0x55, 0x43, 0x65,
      },
      {
            0x28, 0xd7, 0x57, 0x2c, 0x76, 0x03, 0xad, 0x00, 0x40, 0x75, 0xc1, 0xa0, 0x30, 0xf1,
            0x28, 0x30, 0xa5, 0x98, 0xa4, 0x8f, 0x51, 0x86, 0x13, 0x96, 0xa7, 0x81, 0x0a, 0x69,
            0xc2, 0xe8, 0x69, 0x89, 0x3f, 0x67, 0x27, 0xe6, 0x8d, 0xc4, 0x40, 0x06, 0xc3, 0x98,
            0x1d, 0x2c, 0x04, 0x54, 0xc8, 0x12, 0xeb, 0xc5, 0xbe, 0xfe, 0x29, 0xa5, 0x84, 0x7f,
            0x9c, 0xfb, 0x18, 0xf0, 0x0a, 0xfd, 0x37, 0xb5, 0xaf, 0xf0, 0x94, 0x80, 0xf5, 0x89,
            0x0b, 0x52, 0xdf, 0xed,
    }
    );


    // And then the serial number.
    test_exchange(c, handle_serial_number,
      {
            0x55, 0x04, 0xb0, 0xec, 0xc5, 0x05, 0xc1, 0xa2, 0x24, 0x2a, 0x56, 0x78, 0xd5, 0x32,
            0xa0, 0xe6, 0x74, 0xa6, 0x2c, 0x5b, 0xb0,
      },
      {
            0x7d, 0x13, 0x44, 0x5e, 0xd2, 0xfd, 0x1b, 0xe4, 0x49, 0xfb, 0x18, 0xb9, 0xfd, 0x63,
            0x81, 0xb7, 0xc2, 0x54, 0xbe, 0xbf, 0x29, 0xc0, 0x94, 0x2a, 0x25, 0x04, 0x7a, 0x51,
            0x09, 0x7d, 0x38, 0x5c, 0x05, 0x33, 0xec, 0xde, 0x77, 0xbf, 0x76, 0x5e, 0x55, 0xe2,
            0x33, 0xd8, 0x68, 0x75, 0xe3, 0x90, 0x9a, 0x9b, 0x3b, 0x83, 0x46, 0x6c, 0xf9, 0x4c,
            0x68, 0x19, 0xc8, 0xfc, 0xdb, 0x84, 0x18, 0x4a, 0x08, 0x88, 0xce, 0x5b, 0xcd, 0x2b,
            0xac, 0x34, 0x1d, 0x0f,
    }
    );

    // And then the model number.
    test_exchange(c, handle_model_number,
      {
            0x9e, 0xf7, 0x09, 0xf5, 0x15, 0x41, 0xb4, 0x5e, 0x12, 0x04, 0x84, 0xfc, 0x0f, 0xce,
            0x52, 0xac, 0xff, 0xc4, 0x21, 0x43, 0x93,
      },
      {
            0xa6, 0x83, 0xf9, 0xd2, 0xfa, 0x9e, 0x2e, 0xc0, 0x15, 0xe4, 0xda, 0xae, 0x71, 0x27,
            0xe6, 0x5f, 0x07, 0x5e, 0x26, 0xac, 0xe6, 0x75, 0xdb, 0x1d, 0x25, 0x3a, 0x36, 0xfc,
            0x98, 0x79, 0x37, 0xb6, 0x00, 0xc7, 0x68, 0xb3, 0xbe, 0x59, 0x46, 0x2a, 0x40, 0xfc,
            0x71, 0x06, 0xca, 0xb3, 0x5f, 0xd9, 0xf9, 0x49, 0x60, 0x7c, 0xd1, 0x1a, 0x0b, 0x2e,
            0xae, 0xaf, 0x5a, 0x17, 0x15, 0x9b, 0x9d, 0x7d, 0xc2, 0xe0, 0xfa, 0x0a, 0x32, 0x84,
            0x07, 0x35, 0x3c, 0xef,
    }
    );

    // And name
    test_exchange(c, handle_name,
      {
            0x35, 0x8c, 0x9d, 0xa2, 0x1f, 0x46, 0xba, 0xf2, 0x2c, 0x23, 0x6a, 0x50, 0x6a, 0xf4,
            0xf0, 0x90, 0xc2, 0x27, 0xb9, 0x9b, 0x34,
      },
      {
            0x3c, 0xc8, 0xf3, 0xc7, 0x7a, 0x56, 0xb0, 0x83, 0x8d, 0x10, 0xe6, 0xaa, 0xf5, 0xba,
            0xc7, 0xfa, 0x20, 0x5b, 0x71, 0x79, 0x56, 0x12, 0x4d, 0x7a, 0x68, 0x80, 0x88, 0x3e,
            0xad, 0x02, 0x95, 0x45, 0xa5, 0x03, 0x49, 0x2d, 0x79, 0x46, 0x2d, 0x08, 0x86, 0x0f,
            0x7e, 0x89, 0x69, 0x92, 0xb9, 0xbe, 0x31, 0x83, 0x24, 0x41, 0xa0, 0xf7, 0xa0, 0x95,
            0x76, 0x09, 0x83, 0x77, 0x32, 0xaa, 0x35, 0xac, 0x96, 0x3e, 0x72, 0x48, 0x9f, 0xa4,
            0x66, 0x99, 0x8c, 0xdd,
    }
    );
    // ADK version...
    test_exchange(c, handle_adk_version,
      {

            0x66, 0x8f, 0xcb, 0x09, 0xd0, 0xd9, 0x1e, 0xdf, 0x7c, 0xa6, 0x47, 0x3b, 0x6f, 0x75,
            0x18, 0x76, 0xd2, 0x04, 0x26, 0x7a, 0x9f,
      },
      {
            0xe4, 0xfb, 0x1e, 0x38, 0x85, 0xca, 0xd9, 0x36, 0xbd, 0xac, 0x36, 0x2a, 0x18, 0xaa,
            0xe5, 0x37, 0x70, 0xee, 0xb7, 0x4f, 0x44, 0xdf, 0xad, 0xdc, 0x05, 0x0a, 0xa1, 0xb1,
            0x98, 0x75, 0x7b, 0x18, 0xb9, 0x9b, 0xcb, 0xc8, 0xf2, 0xba, 0xd9, 0xa7, 0xb9, 0xef,
            0x79, 0x52, 0x24, 0xf1, 0x1e, 0xc8, 0x44, 0xeb, 0x89, 0x11, 0x67, 0xa7, 0xc9, 0x6b,
            0xec, 0xce, 0xb4, 0x25, 0x1a, 0x28, 0x6d, 0x2c, 0x09, 0xc8, 0xb0, 0xbc, 0xbf, 0x99,
            0xf1, 0x25, 0x62, 0xeb,
    }
    );
    // Manufacturer
    test_exchange(c, handle_manufacturer,
      {


            0x32, 0x72, 0x7c, 0x3b, 0x59, 0x40, 0xdd, 0xba, 0x59, 0x82, 0xab, 0x76, 0xe7, 0x21,
            0x1a, 0x99, 0x5c, 0xd8, 0xc1, 0x3b, 0x35,
      },
      {
            0x33, 0x7a, 0x6b, 0x4f, 0x53, 0x01, 0xdf, 0x0b, 0x98, 0xe0, 0x85, 0x94, 0xbf, 0x2c,
            0xb2, 0x2f, 0x3c, 0x2f, 0x64, 0x75, 0x28, 0xb0, 0xcd, 0xf6, 0xdf, 0x68, 0x03, 0xcb,
            0x65, 0x87, 0x57, 0x0f, 0x4d, 0x48, 0xa7, 0x15, 0xd7, 0x4b, 0x77, 0x2e, 0xf9, 0x31,
            0x2a, 0xcd, 0x8a, 0x1d, 0x3a, 0x10, 0x8d, 0xeb, 0xf0, 0xe5, 0x79, 0xcb, 0x09, 0xa9,
            0x7d, 0xd5, 0x0f, 0xcc, 0x40, 0x94, 0x4f, 0x9b, 0x7f, 0x3d, 0x7a, 0xf8, 0x72, 0xee,
            0xda, 0x0e, 0xbe, 0x7d,
    }
    );
    // Firmware version
    test_exchange(c, handle_firmware_version,
      {
            0x56, 0x55, 0x73, 0x57, 0xf1, 0xc2, 0x41, 0x16, 0xe5, 0x78, 0x9d, 0x36, 0xec, 0xfd,
            0x2d, 0x9a, 0xf5, 0x96, 0x7c, 0x7c, 0x5a,
      },
      {
            0xf1, 0x35, 0x2c, 0xc3, 0xb2, 0x9b, 0x52, 0xd1, 0x36, 0x45, 0xf4, 0x02, 0x26, 0x60,
            0x2e, 0xa8, 0xdc, 0x6a, 0x1e, 0x02, 0x99, 0x0c, 0x0e, 0x06, 0xd1, 0x6a, 0x41, 0xdc,
            0x10, 0xa7, 0x76, 0xce, 0xb1, 0xf4, 0x17, 0x64, 0x89, 0xd4, 0xc8, 0xc6, 0xcb, 0xcc,
            0x8f, 0xdc, 0x74, 0xca, 0x4d, 0x2a, 0x60, 0x07, 0xa1, 0xcb, 0xc4, 0x9e, 0x46, 0x6b,
            0x7a, 0xf3, 0xa5, 0x7a, 0x96, 0x60, 0x78, 0x15, 0xf0, 0x19, 0x17, 0x1f, 0x26, 0x93,
            0xea, 0x68, 0x6f, 0xff,
    }
    );
    test_exchange(c, handle_identify,
      {
            0x9e, 0x8a, 0xcf, 0xd9, 0xe7, 0x39, 0x9e, 0xec, 0x96, 0x8b, 0x9b, 0x22, 0xcf, 0xde,
            0x21, 0x30, 0x4f, 0xb6, 0xfe, 0x26, 0x1a,
      },
      {
            0x2c, 0x30, 0xaa, 0xf1, 0x38, 0x5a, 0x05, 0xb6, 0xeb, 0x26, 0x3f, 0x8c, 0x20, 0x68,
            0xba, 0x46, 0x55, 0x2d, 0x7f, 0x40, 0x42, 0x51, 0xff, 0xf9, 0x71, 0xdf, 0xb3, 0xbe,
            0x1c, 0xc8, 0x44, 0x62, 0x34, 0xa2, 0x91, 0xb1, 0xa2, 0x47, 0x33, 0x05, 0xef, 0x82,
            0x75, 0x13, 0x6c, 0xe6, 0x04, 0x87, 0xba, 0xf5, 0x66, 0xfa, 0xe7, 0xdb, 0x21, 0x7a,
            0x10, 0xed, 0x22, 0xbd, 0x1d, 0xa6, 0xbd, 0xca, 0xbf, 0x24, 0x90, 0x5b, 0x89, 0x0f,
            0xae, 0x1b, 0x8c, 0xd3,
    }
    );

    // Service signature?
    test_exchange(c, handle_protocol_service_signature,
      {
                    0x94, 0xac, 0x60, 0xfe, 0xec, 0x02, 0x29, 0xbb, 0x88, 0x07, 0x87, 0x95, 0xfb,
                    0x76, 0xf2, 0xb6, 0x67, 0x91, 0x3e, 0xf0, 0xa4,
      },
      {
                    0x49, 0x55, 0x89, 0x02, 0x21, 0x6e, 0x10, 0xdb, 0x76, 0x96, 0x2e, 0x53, 0x66,
                    0xa4, 0xca, 0x06, 0x3d, 0xbf, 0x84, 0xe2, 0xad, 0x82, 0x27, 0x33, 0xf2, 0xb5,
                    0x85,
    }
    );
    // Service signature?
    test_exchange(c, handle_protocol_service_signature,
      {
                    0x5a, 0x59, 0x70, 0x78, 0x9d, 0xd3, 0xec, 0x0d, 0x66, 0xad, 0x69, 0x05, 0xfa,
                    0xb6, 0xaf, 0x25, 0x64, 0x79, 0xf6, 0x34, 0xe6,
      },
      {
                    0x92, 0x7c, 0xb2, 0xde, 0xfb, 0x33, 0xf6, 0x74, 0xea, 0xe9, 0x7b, 0xe8, 0x94,
                    0xba, 0x2d, 0x73, 0x30, 0x81, 0x2b, 0x1a, 0xf6, 0xe1, 0xa9, 0x78, 0x93, 0xe3,
                    0xf8, 0x76, 0xc5, 0x95, 0x86, 0x7f, 0xd5, 0x90, 0x79, 0xf3, 0x4b, 0x41, 0x74,
                    0x91, 0xe4, 0x80, 0x74, 0x24, 0xd2, 0x40, 0x06, 0xc5, 0x79, 0x61, 0x6f, 0xa4,
                    0x84, 0xfa, 0x8d, 0x55, 0xcb, 0x38, 0x7e, 0x4e, 0x5d, 0x4b, 0xbd, 0x61, 0xcd,
                    0x90, 0x8d, 0x70, 0xa5, 0x2b, 0x0b, 0x86, 0x1a, 0x56,
    }
    );
    // Protocol Version

    test_exchange(c, handle_protocol_version,
      {
            0x28, 0xb4, 0x47, 0x6f, 0x30, 0x31, 0xcb, 0x3b, 0xc1, 0xa6, 0x81, 0x61, 0x60, 0xc8,
            0xf9, 0x6a, 0xb7, 0x88, 0x0e, 0x5a, 0x94,
      },
      {
            0x12, 0x94, 0x43, 0xa9, 0x7f, 0xd4, 0xba, 0x87, 0x38, 0x3b, 0xd6, 0x68, 0xfd, 0x61,
            0x0f, 0x38, 0x71, 0x1c, 0xc8, 0x65, 0xf6, 0x28, 0xbc, 0x02, 0x8b, 0x17, 0xfe, 0x0e,
            0x77, 0xc3, 0xdf, 0xaf, 0xab, 0x4e, 0xec, 0xd0, 0xe9, 0x9f, 0xc2, 0xc8, 0x3d, 0x5c,
            0x73, 0x87, 0x71, 0xd1, 0x07, 0x2e, 0xb0, 0x5a, 0xe5, 0x88, 0x7a, 0xed, 0x3b, 0xfa,
            0x98, 0xd8, 0x60, 0xcd, 0x97, 0xaf, 0x60, 0x5c, 0x91, 0xa4, 0x33, 0x33, 0xe3, 0x79,
            0xf6, 0x18, 0x6f, 0xf0,
    }
    );

    // Pairings pairings
    test_exchange(c, handle_pairing_pairings,
      {
            0x62, 0xab, 0xff, 0xf9, 0xd7, 0x02, 0xc2, 0x38, 0x11, 0x28, 0x0b, 0xe9, 0xef, 0xe7,
            0x0b, 0xe9, 0x11, 0x4a, 0x2a, 0x7c, 0x36,
      },
      {
            0xd3, 0x00, 0xec, 0x96, 0xdc, 0xde, 0x03, 0x87, 0x82, 0x85, 0x0e, 0x0a, 0x67, 0x8c,
            0x46, 0xdf, 0xc0, 0x9d, 0x7f, 0xc3, 0x98, 0x3b, 0xab, 0x52, 0x34, 0xeb, 0x7c, 0x38,
            0x5b, 0x35, 0x41, 0xae, 0x7f, 0x96, 0x4b, 0x5b, 0x85, 0x17, 0x91, 0x44, 0x3e, 0xdc,
            0xcc, 0xa2, 0xa7, 0x80, 0xbb, 0xf1, 0xb2, 0xae, 0xd7, 0x9e, 0x4a, 0x84, 0xd3, 0x6b,
            0xc8, 0x56, 0x65, 0xce, 0x34, 0x1d, 0xab, 0x20, 0xa5, 0x17, 0x99, 0x78, 0x85, 0x56,
            0x64, 0x28, 0x87, 0x5c,
    }
    );
    // Service signature on the lightbulb service.
    test_exchange(c, handle_lightbulb_service_signature,
      {
            0xef, 0xdd, 0xe0, 0xf7, 0xc8, 0x2a, 0xec, 0x9e, 0xa5, 0xcc, 0x78, 0x68, 0x03, 0x1c,
            0x40, 0x68, 0xc0, 0x8e, 0x47, 0xbb, 0x36,
      },
      {
            0x9d, 0xfe, 0x33, 0xf3, 0xb3, 0x4e, 0x91, 0xa1, 0x97, 0x09, 0x19, 0x49, 0xe3, 0x8a,
            0x5a, 0xa7, 0x46, 0x50, 0x4b, 0x05, 0x0e, 0xc4, 0xd2, 0x81, 0x46, 0x9c, 0x84
    }
    );
    // service sig again!
    test_exchange(c, handle_lightbulb_service_signature,
      {
            0x1f, 0x72, 0x43, 0xdd, 0x38, 0x37, 0xf6, 0xab, 0x2a, 0x5d, 0x11, 0x03, 0xd1, 0xc9,
            0xe5, 0x5a, 0xf5, 0x37, 0xab, 0x93, 0x41,
      },
      {
            0xf8, 0x36, 0x5b, 0x0e, 0x79, 0x60, 0x84, 0xed, 0x09, 0x8c, 0xd5, 0x93, 0x3c, 0x5d,
            0x5f, 0x3a, 0xb0, 0x1f, 0x66, 0x2d, 0xe2, 0x90, 0x22, 0x7b, 0xac, 0xd8, 0xd3, 0xc7,
            0xdb, 0xb1, 0xb8, 0xba, 0xba, 0x47, 0xc1, 0x22, 0x84, 0x6f, 0x72, 0x75, 0x3b, 0xba,
            0xc2, 0x18, 0x96, 0x8e, 0xeb, 0xaa, 0xb4, 0x2a, 0x15, 0x3e, 0x88, 0xed, 0x10, 0x81,
            0xcc, 0x8b, 0xce, 0xf6, 0x96, 0xe4, 0x89, 0x24, 0x6b, 0xf0, 0x11, 0xb5, 0x72, 0x17,
            0xdd, 0x4c, 0x98, 0x40,
    }
    );
    // Characteristic signature read on the 'On' characteristic!
    test_exchange(c, handle_lightbulb_on,
      {
            0x36, 0x56, 0xec, 0xae, 0xff, 0x04, 0xf0, 0x8d, 0x37, 0x5b, 0x29, 0xd1, 0x1d, 0x4b,
            0x77, 0xf8, 0x17, 0xe4, 0x85, 0x3f, 0x1a,
      },
      {
            0xc7, 0xb5, 0x35, 0x28, 0xde, 0x0c, 0xe6, 0x16, 0xa8, 0xac, 0xe8, 0x3f, 0x5c, 0x12,
            0x96, 0xe2, 0x5b, 0xe8, 0xfd, 0x62, 0xe5, 0x9d, 0xed, 0x3b, 0xb6, 0x0c, 0x11, 0x5f,
            0xe9, 0xb2, 0xaa, 0xd1, 0xea, 0x91, 0x88, 0x7f, 0x20, 0x75, 0x49, 0x75, 0x98, 0xde,
            0xa9, 0xe1, 0x63, 0x7c, 0xbe, 0x60, 0x29, 0x31, 0x1d, 0xcc, 0xde, 0xc3, 0xd9, 0x24,
            0x60, 0x6e, 0x0f, 0x92, 0x7d, 0xb3, 0x41, 0xdb, 0x6e, 0x81, 0xa7, 0xc8, 0x82, 0x23,
            0x7c, 0xbf, 0x70, 0x01,
    }
    );


    // Something on the name handle.
    test_exchange(c, handle_lightbulb_name,
      {
            0xe1, 0x16, 0x70, 0x52, 0xa7, 0x1e, 0x17, 0x9d, 0x53, 0x90, 0x83, 0xc2, 0x96, 0x6a,
            0x16, 0xa9, 0x4a, 0x56, 0x1d, 0xd4, 0xb4,
      },
      {
            0xc0, 0x1f, 0xe4, 0x04, 0x88, 0xb1, 0xcd, 0xa1, 0x36, 0x05, 0x70, 0xb3, 0x81, 0x8f,
            0x8b, 0x31, 0x85, 0x8f, 0x80, 0x20, 0xbc, 0xf2, 0x0a, 0x09, 0xd9, 0x6e, 0x00, 0x4c,
            0xf0, 0xf3, 0x4d, 0x47, 0x8d, 0x85, 0xfe, 0x7a, 0xff, 0xb1, 0xd5, 0x99, 0xe9, 0xc8,
            0xea, 0xde, 0xdd, 0xd4, 0xd2, 0xfb, 0x2c, 0x0f, 0x63, 0x7f, 0x95, 0x75, 0x38, 0x58,
            0x40, 0x74, 0x08, 0x4a, 0xda, 0xbf, 0xe1, 0x98, 0xc5, 0xe8, 0x0f, 0x03, 0x6c, 0xb5,
            0xc1, 0xb1, 0x4f, 0x5b,
    }
    );

    // Now we read the firmware revision string!
    test_exchange(c, handle_firmware_version,
      {
            0x08, 0x0e, 0xc5, 0xff, 0x16, 0x22, 0x78, 0x24, 0xb6, 0xfc, 0x81, 0x4e, 0xf8, 0x28,
            0x14, 0x67, 0xa8, 0xb1, 0xed, 0x6b, 0xb9,
      },
      {
            0x51, 0x1e, 0x94, 0x9a, 0xa4, 0x75, 0x93, 0xaf, 0x60, 0xb4, 0xa6, 0xd3, 0x2c, 0xa4,
            0x2f, 0xf5, 0xca, 0x2a, 0x34, 0xeb, 0x4f, 0x70, 0x0e, 0x39,
    }
    );
    // Manufacturer
    test_exchange(c, handle_manufacturer,
      {
            0x05, 0x76, 0xd3, 0xaf, 0x2f, 0xa0, 0xdd, 0xd1, 0x2c, 0x0b, 0xa8, 0xdd, 0xf2, 0x7a,
            0xe3, 0x0b, 0x53, 0x4e, 0x07, 0xb8, 0x9c,
      },
      {
            0x71, 0xea, 0xd2, 0xfb, 0xe8, 0x12, 0xef, 0x4d, 0x7f, 0x86, 0x08, 0x3d, 0x00, 0xe7,
            0xec, 0xe3, 0x66, 0x33, 0x18, 0xd8, 0x0e, 0x37, 0xd4, 0x37, 0x29, 0x50, 0x11,
    }
    );

    // Model
    test_exchange(c, handle_model_number,
      {
            0xf8, 0xbd, 0xaf, 0x7d, 0x21, 0xbd, 0xa1, 0x50, 0x1f, 0x3c, 0x78, 0xe7, 0x86, 0x72,
            0x30, 0xf3, 0x07, 0x8f, 0x6c, 0x91, 0xd9,
      },
      {
            0xc7, 0xfb, 0xd3, 0x79, 0x6c, 0x67, 0x9c, 0x6c, 0x59, 0xc0, 0x55, 0x75, 0x46, 0x4c,
            0x26, 0xf3, 0xce, 0x8f, 0xe8, 0x65, 0x2f, 0xc6, 0x58, 0x84, 0x9a, 0x21, 0x47, 0x14,
            0xf5, 0xa2, 0x51, 0x90, 0x0e, 0x81, 0x51,
    }
    );


    // Serial number
    test_exchange(c, handle_serial_number,
      {
            0x56, 0xac, 0x55, 0x8e, 0xf6, 0x0f, 0x3a, 0xbd, 0x2c, 0x8a, 0xf5, 0xc4, 0x47, 0x0a,
            0x13, 0x1c, 0x72, 0x38, 0x7f, 0xd0, 0x71,
      },
      {
            0x51, 0x47, 0x7e, 0x71, 0x5d, 0x5d, 0xff, 0xb4, 0xf6, 0x05, 0x60, 0xbc, 0xce, 0x95,
            0x70, 0xea, 0x91, 0xd9, 0x93, 0x62, 0xda, 0xdb, 0x4f, 0xd0, 0x7f, 0x47, 0x62, 0x82,
            0x2c, 0xfe, 0x64, 0x79, 0x10, 0xf9, 0xf3,
    }
    );
    // Name
    test_exchange(c, handle_name,
      {
            0x6b, 0x2e, 0x57, 0x9b, 0xb2, 0xa6, 0x59, 0xcc, 0xab, 0xee, 0x34, 0x11, 0x71, 0xb7,
            0xe3, 0x40, 0x0a, 0xb6, 0xc9, 0x70, 0x48,
      },
      {
            0xb4, 0x39, 0x0e, 0x0f, 0x87, 0x16, 0x2b, 0xfd, 0x43, 0xaf, 0xc8, 0xc0, 0x01, 0x75,
            0x0f, 0x78, 0xb4, 0x9b, 0x78, 0xda, 0xcd, 0x49, 0x72, 0xa8, 0x70, 0x33, 0xbd, 0xc4,
            0x91, 0xd5, 0xfd, 0x2c, 0x59, 0x25, 0x8b, 0xfb, 0xd9, 0x6a,
    }
    );



    // Name
    test_exchange(c, handle_lightbulb_name,
      {
            0xc5, 0x3b, 0x1c, 0xbf, 0xab, 0x35, 0x4b, 0x41, 0x58, 0x8f, 0xdc, 0xab, 0x9c, 0xd6,
            0xef, 0xa7, 0xa3, 0x0b, 0xe5, 0x26, 0xf6,
      },
      {
            0x1b, 0x7e, 0x60, 0x55, 0x10, 0x0e, 0x09, 0x80, 0x26, 0x51, 0x7b, 0xce, 0x35, 0x11,
            0x3c, 0xc8, 0x0d, 0x2f, 0x5b, 0xb0, 0x87, 0x91, 0x78, 0x7d, 0x84, 0x6c, 0xd3, 0x76,
            0xb5, 0x24, 0x78, 0x5a, 0xdb,
    }
    );
    // Write to service signature -> Protocol Configuration!
    test_exchange(c, handle_protocol_service_signature,
      {
            0xdb, 0x5c, 0xf3, 0x57, 0x88, 0x99, 0x53, 0xab, 0xc5, 0xa1, 0x7d, 0xa1, 0x45, 0xdd,
            0x70, 0x09, 0x4f, 0x5b, 0x9a, 0xa5, 0xbf, 0xa3, 0x2e, 0x3b, 0x6d, 0x54, 0x2f,
      },
      {
            0x74, 0x1a, 0x67, 0x4a, 0x9f, 0x3b, 0xe7, 0x03, 0xac, 0xb2, 0xda, 0x38, 0x42, 0x2d,
            0x01, 0x9f, 0xf3, 0x66, 0x7a, 0x5b, 0x14, 0x63, 0xf0, 0xc6, 0x30, 0x48, 0x8f, 0xa7,
            0xcb, 0x7e, 0xa5, 0x8b, 0xfb, 0xb7, 0xa8, 0xd9, 0xed, 0xc8, 0x25, 0x2d, 0xe1, 0x31,
            0xd3, 0xd4, 0xc3, 0xf3, 0xb0, 0x4f, 0x9e, 0x2d, 0xb0, 0x1f, 0x6a, 0xec, 0x29, 0x08,
            0x88, 0xdb, 0x08, 0xc9, 0xbb, 0x16, 0x2c, 0x9a, 0xd2, 0x0a, 0x5b, 0x08, 0x66, 0x8a,
    }
    );

    // Write request to name
    test_exchange(c, handle_name,
      {
            0x5e, 0x7b, 0xa0, 0x2b, 0x34, 0xcf, 0x30, 0xeb, 0xa5, 0xab, 0x30, 0xd9, 0x1d, 0x3e,
            0x75, 0xa7, 0xef, 0xbb, 0xf3, 0x22, 0x6b,
      },
      {
            0xb9, 0x71, 0xfc, 0x5a, 0x41, 0xe5, 0xc8, 0xd0, 0x57, 0x51, 0x0a, 0x9c, 0x4b, 0x3d,
            0x05, 0x47, 0x21, 0xf7, 0xd9, 0xa7, 0xa9, 0xc2, 0xcd, 0x2e, 0xd3, 0xb6, 0x10, 0x45,
            0x9c, 0x22, 0x12, 0x00, 0xd8, 0xf4, 0x62, 0x64, 0xb3, 0xc6,
    }
    );


    // Write request to name
    test_exchange(c, handle_firmware_version,
      {
            0x21, 0x23, 0x0f, 0xbd, 0x0b, 0xf6, 0x1d, 0xef, 0x31, 0xe1, 0xfb, 0xaa, 0x09, 0x48,
            0xd5, 0xb2, 0x1c, 0x6e, 0x89, 0x51, 0xc9,
      },
      {
            0x00, 0xb3, 0x6c, 0x60, 0x8e, 0x80, 0x80, 0x5c, 0x75, 0x03, 0xb5, 0xdb, 0x85, 0x54,
            0x96, 0xc2, 0x70, 0x2e, 0xcf, 0xdc, 0x0c, 0xef, 0x75, 0xdc,
    }
    );


    // Write to name... three times... oh, different handles.
    test_exchange(c, handle_lightbulb_name,
      {
                    0xa0, 0x04, 0x3c, 0x53, 0xab, 0xfb, 0xcd, 0x12, 0xaa, 0x11, 0x9b, 0xc7, 0x7c,
                    0xf1, 0xdf, 0x26, 0x9b, 0x13, 0x51, 0x71, 0x6c,
      },
      {
                    0xbb, 0xe5, 0x86, 0x80, 0x08, 0xea, 0xfe, 0xbf, 0xda, 0x2a, 0xf5, 0xbd, 0x76,
                    0x1f, 0x63, 0x63, 0x0a, 0xc7, 0x56, 0x27, 0x1c, 0x2f, 0x37, 0x9a, 0xa5, 0xca,
                    0x36, 0x01, 0xfd, 0xa5, 0x9e, 0x2a, 0xda,
    }
    );


    // Write to name... three times... oh, different handles.
    test_exchange(c, handle_lightbulb_name,
      {
                    0xf8, 0xf7, 0x74, 0x51, 0xd9, 0x19, 0x82, 0x13, 0x6f, 0x74, 0x93, 0x6a, 0xb4,
                    0x6d, 0xb4, 0xe2, 0x52, 0x97, 0x2d, 0xe9, 0xcd,
      },
      {
                    0x75, 0x72, 0xd3, 0x03, 0x1c, 0x1d, 0x46, 0x1b, 0xa4, 0xba, 0x08, 0x11, 0x20,
                    0xb8, 0x56, 0xb5, 0xac, 0x44, 0xb5, 0xf1, 0x30, 0xbc, 0xc9, 0xfc, 0xd9, 0x60,
                    0xbc, 0x59, 0xcb, 0x78, 0xb4, 0x49, 0x7b,
    }
    );


    // Write to name... three times... oh, different handles.
    test_exchange(c, handle_name,
      {
                    0x84, 0x32, 0x35, 0x2a, 0x17, 0xa9, 0x03, 0x54, 0x56, 0xf8, 0x41, 0x3f, 0x30,
                    0x83, 0x35, 0x4e, 0xd7, 0x52, 0x62, 0x3e, 0x12,
      },
      {
                    0x97, 0x31, 0x55, 0x88, 0xbf, 0x18, 0x00, 0x0c, 0x60, 0x08, 0x56, 0x77, 0xa9,
                    0x4f, 0x8c, 0xc2, 0x57, 0x83, 0x51, 0x7e, 0x9f, 0x0e, 0x0d, 0x32, 0xd8, 0x3c,
                    0x80, 0xb8, 0x48, 0x33, 0xa8, 0x6c, 0x9e, 0x90, 0x72, 0x33, 0xd3, 0x7e,
    }
    );



    // And then, a write to on.
    test_exchange(c, handle_lightbulb_on,
      {
                0xec, 0x4b, 0x97, 0xbd, 0x2f, 0xcf, 0x72, 0x7f, 0x2f, 0xf9, 0x69, 0x94, 0x64, 0x8b,
                0x55, 0x75, 0x58, 0xb1, 0xed, 0xaf, 0x75, 0x7d, 0xd5, 0x82, 0x16, 0xbc, 0xb5, 0x52,
                0x4e, 0x78,
      },
      {
                0xcd, 0xa9, 0x7e, 0x31, 0x07, 0xb8, 0x08, 0x94, 0xea, 0xd6, 0x86, 0x8b, 0x13, 0x60,
                0x17, 0xc5, 0xe1, 0x6c, 0xc7, 0x8e, 0x7a, 0xbc, 0x54, 0xdf, 0xfb, 0xc3, 0x9d, 0xe3,
    }
    );

    // Another write on on the lightbulb!
    test_exchange(c, handle_lightbulb_on,
      {
                        0x62, 0x23, 0x31, 0x37, 0x2f, 0xf0, 0x06, 0x49, 0xaf, 0xcb, 0x62, 0x07,
                        0xdb, 0x24, 0xe1, 0x6f, 0x41, 0x9d, 0x3e, 0xe0, 0x1e,
      },
      {
                        0x4a, 0x16, 0x2b, 0x72, 0x80, 0x44, 0x98, 0x00, 0x04, 0x01, 0x24, 0xc8,
                        0x5a, 0xff, 0xec, 0x83, 0xa6, 0xf5, 0xe3, 0xa3, 0xc5, 0x73, 0x71, 0xb1,
    }
    );

    test_exchange(c, handle_lightbulb_on,
      {
                        0xd1, 0xdc, 0x5e, 0x02, 0x11, 0x6d, 0x75, 0x31, 0xa7, 0x51, 0x4d, 0x42,
                        0xac, 0x61, 0x42, 0x3a, 0x71, 0xb8, 0x16, 0x93, 0x63,
      },
      {
                        0x53, 0x82, 0x18, 0xca, 0xf4, 0x7f, 0x5f, 0xb0, 0x79, 0x37, 0x45, 0x63,
                        0xcf, 0xca, 0xb5, 0x69, 0x9a, 0x4e, 0x6c, 0x3f, 0x5e, 0x28, 0x96, 0x54,
    }
    );


    appendRandomBytes({0x4b, 0xff, 0x03, 0x1d, 0x7d, 0x97, 0x5f, 0x01});
    // And now we go into pair verify yet again!
    // Feed the device the necessary random.
    test_exchange(c, pairing_pair_verify,
      {
                0x00, 0x02, 0x61, 0x23, 0x00, 0x49, 0x00, 0x01, 0x44, 0x06, 0x01, 0x01, 0x00, 0x01,
                0x06, 0x0e, 0x08, 0x19, 0xaa, 0x62, 0xff, 0xbe, 0xf3, 0x84, 0x94, 0x05, 0x10, 0x3f,
                0x50, 0x1c, 0xa6, 0x65, 0xe4, 0xa7, 0x45, 0x33, 0xf9, 0x29, 0x14, 0x5a, 0xe3, 0x52,
                0x2e, 0x03, 0x20, 0xfe, 0x6c, 0x05, 0xc7, 0x34, 0xa5, 0xf0, 0x04, 0x59, 0x0e, 0xa5,
                0x8e, 0x5c, 0x9f, 0x6c, 0x31, 0xd6, 0x36, 0xc1, 0xd4, 0x7b, 0xd5, 0xc5, 0x31, 0x6d,
                0x68, 0xac, 0x3f, 0x5d, 0x87, 0x79, 0x28, 0x09, 0x01, 0x01,
      },
      {
                0x02, 0x61, 0x00, 0x24, 0x00, 0x01, 0x22, 0x06, 0x01, 0x02, 0x00, 0x01, 0x06, 0x0e,
                0x08, 0x4b, 0xff, 0x03, 0x1d, 0x7d, 0x97, 0x5f, 0x01, 0x05, 0x10, 0x7a, 0x38, 0x77,
                0x82, 0x85, 0x2a, 0xdf, 0xc4, 0x38, 0x40, 0x7e, 0x49, 0x49, 0x0d, 0x27, 0x98,
    }
    );


    // Next we have an write to the ON characteristic, this seems to be the real first toggle?
    test_exchange(c, handle_lightbulb_on,
      {
            0x72, 0xb3, 0x58, 0x33, 0x0f, 0xc7, 0xb2, 0x16, 0x74, 0xbe, 0x51, 0xcf, 0x82, 0xa4,
            0x1b, 0x1b, 0x14, 0x96, 0x15, 0x2f, 0x4a, 0x0d, 0x7a, 0x88, 0x9a, 0x57,
      },
      {
            0x57, 0xc9, 0x4a, 0xf0, 0x9f, 0x5a, 0x32, 0xe3, 0xf1, 0x41, 0xc8, 0x50, 0x4a, 0x0b,
            0x86, 0x06, 0x9d, 0xb7, 0x98,
    }
    );

    test_exchange(c, handle_lightbulb_on,
      {
            0x66, 0xf5, 0x79, 0xc9, 0x36, 0xf0, 0x6d, 0xe7, 0x44, 0xc9, 0x9e, 0x6c, 0xfa, 0xa4,
            0x9f, 0xd9, 0x1e, 0x88, 0xea, 0x09, 0xdd, 0x9c, 0x02, 0x89, 0x61, 0xb6,
      },
      {
            0x30, 0xc7, 0xd8, 0xe2, 0x96, 0x4e, 0xef, 0x42, 0xdd, 0x70, 0xf9, 0x0e, 0xe0, 0x12,
            0xb1, 0xd4, 0x23, 0x2b, 0x60,
    }
    );
    // Next follows the timed write test from rust.
    // This TimedWrite payload is from 2025_08_22_1430_homekitadk_pair_disconnect_connect_toggle.txt

    // Next, we perform a disconnect, then connect again and try a pair resume.
    //
    // Disconnect.
    (*(c->delegate.handleDisconnectedCentral))(c->manager, c->connection_handle, c->delegate.context);
    // COnnect again.
    c->connection_handle++;
    (*(c->delegate.handleConnectedCentral))(c->manager, c->connection_handle, c->delegate.context);


    // Now we do the pair resume.
    {
      // Super legit random...
      for (std::size_t n = 0; n < 32; n++){
          appendRandomBytes({n});
      }
    }
    test_exchange(c, pairing_pair_verify,
      {
        0, 2, 95, 35, 0, 73, 0, 1, 68, 6, 1, 1, 0, 1, 6, 14, 8, 117, 120, 116, 50, 165, 39, 80, 173, 5, 16, 28, 188, 210, 81, 134, 137, 130, 27, 114, 95, 36, 68, 212, 131, 7, 178, 3, 32, 179, 38, 60, 29, 24, 170, 94, 234, 67, 180, 116, 204, 115, 55, 140, 210, 21, 35, 47, 53, 194, 183, 218, 20, 13, 164, 143, 239, 175, 111, 4, 50, 9, 1, 1,
      },
      {

    }
    );
    //
    //
    //
    //
    //
    //
    std::cout << "Test message exchange ran to completion." << std::endl;
    std::exit(0);
}


void writeSaltAndVerifier(const Bytes& salt, const Bytes& verifier) {
  HAPLogInfo(&logObject, "Writing salt and verifier to file");
  std::ofstream file("40.10", std::ios::binary);
  if (file.is_open()) {
      file.write(reinterpret_cast<const char*>(salt.data()), salt.size());
      file.write(reinterpret_cast<const char*>(verifier.data()), verifier.size());
      file.close();
  } else {
      HAPLogError(&logObject, "Unable to open file for writing");
  }
}

void writeLongtermSecretKey(const Bytes& sk){
  HAPLogInfo(&logObject, "writeLongtermSecretKey");
  std::ofstream file("90.21", std::ios::binary);
  if (file.is_open()) {
      file.write(reinterpret_cast<const char*>(sk.data()), sk.size());
      file.close();
  } else {
      HAPLogError(&logObject, "Unable to open file for writing");
  }
}

void writeStateMarker() {
  std::ofstream file("00.00", std::ios::binary);
  file << '\x00';
  file.close();
}

void writeDeviceId(const Bytes& data) {
  std::ofstream file("90.00", std::ios::binary);
  file.write(reinterpret_cast<const char*>(data.data()), data.size());
  file.close();
}
void writePairFourLetter(const Bytes& data) {
  std::ofstream file("40.11", std::ios::binary);
  file.write(reinterpret_cast<const char*>(data.data()), data.size());
  file.close();
}


// This function is called when a read is done
// Use this to set the characteristic value if it is not set or to reject the read request
Bytes on_local_char_read(const OurBLEContainer* c,   const char *service_uuid, const char *char_uuid) {

  CharacteristicId key = CharacteristicId::service_characteristic(service_uuid, char_uuid);
  std::string key_str = key;
  HAPLogError(&logObject, "Reading %s with %p", key_str.c_str(), c);

  const auto handle_it = c->characteristic_handles.find(key);
  HAPAssert(handle_it != c->characteristic_handles.end());

  const auto handle_id = handle_it->second;

  Bytes bytes;
  bytes.resize(kHAPPlatformBLEPeripheralManager_MaxAttributeBytes);
  size_t len = 0;

  HAPError err = c->delegate.handleReadRequest(
                      c->manager,
                      c->connection_handle,
                      handle_id,
                      bytes.data(),
                      kHAPPlatformBLEPeripheralManager_MaxAttributeBytes,
                      &len,
                      c->delegate.context);
  bytes.resize(len);
  HAPLogInfo(&logObject, "handleReadRequest returned %d, len is now: %zu", err, len);
  if (err != kHAPError_None ) {
    HAPAssert(err == kHAPError_InvalidState || err == kHAPError_OutOfResources);
    //return BLUEZ_ERROR_REJECTED;
    throw 1;
  }
  hexdump(bytes);
  return bytes;
}

// This function should be used to validate or reject a write request
bool on_local_char_write(const OurBLEContainer* c,  const char *service_uuid, const char *char_uuid, Bytes byteArray) {
 // hexdump(byteArray);
  ///HAPLogError(&logObject, "write request characteristic <%s> with value <%s>", char_uuid, result->str);


  CharacteristicId key = CharacteristicId::service_characteristic(service_uuid, char_uuid);
  std::string key_str = key;
  HAPLogError(&logObject, "Writing to  %s with %p", key_str.c_str(), c);

  const auto handle_it = c->characteristic_handles.find(key);
  HAPAssert(handle_it != c->characteristic_handles.end());

  const auto handle_id = handle_it->second;

  uint8_t bytes[kHAPPlatformBLEPeripheralManager_MaxAttributeBytes] = { 0 };
  size_t len = byteArray.size();
  // Copy from the gbyte array into our buffer.
  memcpy(bytes, byteArray.data(), len);
  hexdump(byteArray );

  // pass the buffer along.
  HAPError err = c->delegate.handleWriteRequest(
          c->manager,
          c->connection_handle,
          handle_id,
          bytes,
          len,
          c->delegate.context);
  HAPLogError(&logObject, "handleWriteRequest returned %d, len was: %zu", err, len);
  if (err) {
      HAPAssert(err == kHAPError_InvalidState || err == kHAPError_OutOfResources);
      return false;
  }
  // Nothing further to do.

  return true;
}


void appendRandomBytes(const Bytes& data){
  for (const auto& z : data){
    random_bytes.push_back(z);
  }
}
extern "C" {
void HAPPlatformRandomNumberFill(void* bytes, size_t numBytes){
  std::uint8_t* dest = reinterpret_cast<std::uint8_t*>(bytes);
  //random_bytes
  for (std::size_t i = 0; i < numBytes; i++){
    if (random_bytes.empty()){
      throw std::runtime_error("Ran out of random bytes.");
    }
    dest[i] = random_bytes.front();
    random_bytes.pop_front();
  }
}


void HAPPlatformBLEPeripheralManagerCreate(
        HAPPlatformBLEPeripheralManagerRef blePeripheralManager,
        const HAPPlatformBLEPeripheralManagerOptions* options) {
  HAPPrecondition(blePeripheralManager);
  HAPPrecondition(options);
  HAPPrecondition(options->keyValueStore);

  if (blePeripheralManager->container == NULL) {
    blePeripheralManager->container = std::make_unique<OurBLEContainer>().release();
  }
  OurBLEContainer* c = blePeripheralManager->container;
  c->manager = blePeripheralManager;

  std::cout << "create" << std::endl;

}

void HAPPlatformBLEPeripheralManagerSetDelegate(
        HAPPlatformBLEPeripheralManagerRef blePeripheralManager_,
        const HAPPlatformBLEPeripheralManagerDelegate* _Nullable delegate_) {
    HAPPrecondition(blePeripheralManager_);

  OurBLEContainer* c = blePeripheralManager_->container;
  if (delegate_) {
    c->delegate = *delegate_;
  }

  HAPLog(&logObject, __func__);
}


void HAPPlatformBLEPeripheralManagerSetDeviceAddress(
        HAPPlatformBLEPeripheralManagerRef blePeripheralManager,
        const HAPPlatformBLEPeripheralManagerDeviceAddress* deviceAddress) {
  HAPPrecondition(blePeripheralManager);
  HAPPrecondition(deviceAddress);

  HAPLog(&logObject, __func__);

  hexdump(deviceAddress, 6);

  uint8_t address_with_colons[sizeof("AA:BB:CC:DD:EE:FF") ] = "AA:BB:CC:DD:EE:FF";
  for (uint8_t bindex = 0; bindex < 6; bindex++){
    const uint8_t* rawbytes = (const uint8_t*)deviceAddress;
    inject_hex(&(address_with_colons[bindex * 3]), rawbytes[bindex]);
  }
  hexdump(address_with_colons, sizeof("AA:BB:CC:DD:EE:FF") );

  HAPLogInfo(&logObject, "Setting address to  to %s", address_with_colons);
  OurBLEContainer* c = blePeripheralManager->container;
  //HAPPrecondition(c->device);

  HAPLogError(&logObject, "much sad, can't set address");
  //binc_device_set_address(c->device, address_with_colons);
}

void HAPPlatformBLEPeripheralManagerSetDeviceName(
        HAPPlatformBLEPeripheralManagerRef blePeripheralManager,
        const char* deviceName) {
  HAPPrecondition(blePeripheralManager);
  HAPPrecondition(deviceName);

  HAPLogInfo(&logObject, "Setting name to %s", deviceName);
  OurBLEContainer* c = blePeripheralManager->container;

  HAPLog(&logObject, __func__);

  HAPLogError(&logObject, "Can't set device name");
}

HAP_RESULT_USE_CHECK
HAPError HAPPlatformBLEPeripheralManagerAddService(
        HAPPlatformBLEPeripheralManagerRef blePeripheralManager,
        const HAPPlatformBLEPeripheralManagerUUID* type,
        bool isPrimary) {
  HAPPrecondition(blePeripheralManager);
  HAPPrecondition(type);

  HAPLog(&logObject, __func__);

  OurBLEContainer* c = blePeripheralManager->container;


  // We cannot handle non primary services, so drop the ball if they are not primary.
  HAPAssert(isPrimary);

  RawUUID b = RawUUID::fromBytes(type->bytes);
  c->recent_service = b;
  hexdump(type->bytes, 16);
  HAPLogInfo(&logObject, "l: %d ", __LINE__);
  HAPLogInfo(&logObject, "l: %d ", __LINE__);


  //c->service();
  return kHAPError_None;
}

void HAPPlatformBLEPeripheralManagerRemoveAllServices(HAPPlatformBLEPeripheralManagerRef blePeripheralManager) {
  HAPPrecondition(blePeripheralManager);

  HAPLog(&logObject, __func__);

  //  [peripheral removeAllServices];
}



HAP_RESULT_USE_CHECK
HAPError HAPPlatformBLEPeripheralManagerAddCharacteristic(
        HAPPlatformBLEPeripheralManagerRef blePeripheralManager,
        const HAPPlatformBLEPeripheralManagerUUID* type,
        HAPPlatformBLEPeripheralManagerCharacteristicProperties properties,
        const void* _Nullable constBytes,
        size_t constNumBytes,
        HAPPlatformBLEPeripheralManagerAttributeHandle* valueHandle,
        HAPPlatformBLEPeripheralManagerAttributeHandle* _Nullable cccDescriptorHandle) {
  HAPPrecondition(blePeripheralManager);
  HAPPrecondition(type);
  HAPPrecondition((!constBytes && !constNumBytes) || (constBytes && constNumBytes));
  HAPPrecondition(valueHandle);
  if (properties.notify || properties.indicate) {
      HAPPrecondition(cccDescriptorHandle);
  } else {
      HAPPrecondition(!cccDescriptorHandle);
  }

  HAPLog(&logObject, __func__);
  OurBLEContainer* c = blePeripheralManager->container;

  const char* recent_service = c->recent_service.str;

  std::string behaviour = to_string(properties);
  HAPLogInfo(&logObject, "add characteristic, const bytes: %lu  behaviour: %s", constNumBytes, behaviour.c_str());
  hexdump(type->bytes, 16);


  RawUUID b = RawUUID::fromBytes(type->bytes);
  c->recent_characteristic = b;
//  guint permissions = makePermission(properties);
 // int res = binc_application_add_characteristic(c->app, recent_service,
  //                                        b.str, permissions);
int res = 0;
  HAPAssert(res == 0);
  CharacteristicId key;
  key.service = c->recent_service;
  key.characteristic = b;
  if (constNumBytes != 0) {
    HAPLogError(&logObject, "Have const data that needs handling.");
    hexdump(constBytes, constNumBytes);
    std::vector<uint8_t> data;
    data.resize(constNumBytes);
    memcpy(data.data(), constBytes, constNumBytes);
    c->characteristic_values[key] = data;
  }

  // Good enough for now?
  c->handle_counter++;
  c->characteristic_handles[key] = c->handle_counter;
  *valueHandle = c->handle_counter;
  if (properties.notify || properties.indicate) {
    *cccDescriptorHandle = c->handle_counter;
  }

  return kHAPError_None;
}

HAP_RESULT_USE_CHECK
HAPError HAPPlatformBLEPeripheralManagerAddDescriptor(
        HAPPlatformBLEPeripheralManagerRef blePeripheralManager,
        const HAPPlatformBLEPeripheralManagerUUID* type,
        HAPPlatformBLEPeripheralManagerDescriptorProperties properties HAP_UNUSED,
        const void* _Nullable constBytes,
        size_t constNumBytes,
        HAPPlatformBLEPeripheralManagerAttributeHandle* descriptorHandle) {
  HAPPrecondition(blePeripheralManager);
  HAPPrecondition(type);
  HAPPrecondition(constBytes && constNumBytes);
  HAPPrecondition(descriptorHandle);

  HAPLog(&logObject, __func__);


  OurBLEContainer* c = blePeripheralManager->container;


  const char* recent_service = c->recent_service.str;
  const char* recent_characteristic = c->recent_characteristic.str;

  HAPLogInfo(&logObject, "add characteristic, const bytes: %zu ", constNumBytes);
  hexdump(type->bytes, 16);

  RawUUID b = RawUUID::fromBytes(type->bytes);
  //guint permissions = makePermissionDescr(properties);

  CharacteristicId char_key;
  char_key.service = c->recent_service;
  char_key.characteristic = c->recent_characteristic;
  DescriptorId key = DescriptorId::characteristic_descriptor(char_key, b.str);

  int res = 0;
  HAPAssert(res == 0);

  if (constNumBytes != 0) {
    HAPLogInfo(&logObject, "Setting const data for descriptor: %s", std::string(b).c_str());
    hexdump(constBytes, constNumBytes);
  }

  // Good enough for now?
  c->handle_counter++;
  c->descriptor_handles[key] = c->handle_counter;
  *descriptorHandle = c->handle_counter;

  return kHAPError_None;
}


void HAPPlatformBLEPeripheralManagerPublishServices(HAPPlatformBLEPeripheralManagerRef blePeripheralManager) {
  HAPPrecondition(blePeripheralManager);

  OurBLEContainer* c = blePeripheralManager->container;
  HAPLog(&logObject, __func__);

  // We're ready to roll, so lets start the application.
  if (!c->registered_application){

    c->registered_application = true;
  }

  // Lets also start a background thread to push the event loop service onto the HAP service loop.
  if (!c->started_main_loop) {

    int r = HAPPlatformRunLoopScheduleCallback(run_main_loop, &c, sizeof(void*));
    HAPAssert(r == kHAPError_None);
  }

}

void HAPPlatformBLEPeripheralManagerStartAdvertising(
        HAPPlatformBLEPeripheralManagerRef blePeripheralManager,
        HAPBLEAdvertisingInterval advertisingInterval,
        const void* advertisingBytes,
        size_t numAdvertisingBytes,
        const void* _Nullable scanResponseBytes,
        size_t numScanResponseBytes) {
  HAPPrecondition(blePeripheralManager);
  HAPPrecondition(advertisingInterval);
  HAPPrecondition(advertisingBytes);
  HAPPrecondition(numAdvertisingBytes);
  HAPPrecondition(!numScanResponseBytes || scanResponseBytes);

  OurBLEContainer* c = blePeripheralManager->container;
  HAPLog(&logObject, __func__);
  HAPLogInfo(&logObject, "advertising bytes: %zu ", numAdvertisingBytes);

  hexdump(advertisingBytes, numAdvertisingBytes);

  // Data contains too much, so we need to trim the first 7 bytes...
  // 0x02,0x01,0x06,0x16,0xff,0x4c,0x00,    0x06,0x31
  //
  //
  int trim = 7;
  const uint8_t* actual_data = ((uint8_t*)advertisingBytes) + trim;
  numAdvertisingBytes = numAdvertisingBytes- trim;
  numAdvertisingBytes = 19; // and just truncate the rear.

  uint16_t COMPANY_IDENTIFIER_CODE =  0x004c;

  //HAPLogFault(&logObject, "pairable before %d", before);
}

void HAPPlatformBLEPeripheralManagerStopAdvertising(HAPPlatformBLEPeripheralManagerRef blePeripheralManager) {
  HAPPrecondition(blePeripheralManager);

  OurBLEContainer* c = blePeripheralManager->container;
  HAPLog(&logObject, __func__);

}

void HAPPlatformBLEPeripheralManagerCancelCentralConnection(
        HAPPlatformBLEPeripheralManagerRef blePeripheralManager,
        HAPPlatformBLEPeripheralManagerConnectionHandle connectionHandle HAP_UNUSED) {
  HAPPrecondition(blePeripheralManager);
  HAPLog(&logObject, __func__);

  // Request a disconnect.
  OurBLEContainer* c = blePeripheralManager->container;
}

HAP_RESULT_USE_CHECK
HAPError HAPPlatformBLEPeripheralManagerSendHandleValueIndication(
        HAPPlatformBLEPeripheralManagerRef blePeripheralManager,
        HAPPlatformBLEPeripheralManagerConnectionHandle connectionHandle,
        HAPPlatformBLEPeripheralManagerAttributeHandle valueHandle,
        const void* _Nullable bytes,
        size_t numBytes) {
  HAPPrecondition(blePeripheralManager);

  HAPLog(&logObject, __func__);

  return kHAPError_None;
}


} // extern C
